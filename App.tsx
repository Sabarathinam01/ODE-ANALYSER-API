
import React, { useState, useCallback } from 'react';
import { OdeModelInput } from './components/OdeModelInput';
import { SimulationControl } from './components/SimulationControl';
import { AnalysisDashboard } from './components/AnalysisDashboard';
import { Hero } from './components/Hero';
import type { SimulationParams, SimulationResult, Parameter, EquilibriumPoint } from './types';
import { rungeKutta4 } from './services/odeSolver';
import { generateOdeFunction, analyzeEquilibriumPoints } from './services/geminiService';

const App: React.FC = () => {
    const [odeString, setOdeString] = useState<string>('dx/dt = sigma * (y - x)\ndy/dt = x * (rho - z) - y\ndz/dt = x * y - beta * z');
    const [variableNames, setVariableNames] = useState<string[]>(['x', 'y', 'z']);
    const [parameters, setParameters] = useState<Parameter[]>([
        { name: 'sigma', value: 10 },
        { name: 'rho', value: 28 },
        { name: 'beta', value: 2.667 },
    ]);
    const [simulationParams, setSimulationParams] = useState<SimulationParams>({
        initialConditions: [1, 1, 1],
        t_start: 0,
        t_end: 100,
        stepSize: 0.01,
        transient: 10,
    });
    const [simulationResult, setSimulationResult] = useState<SimulationResult | null>(null);
    const [equilibriumData, setEquilibriumData] = useState<{ points: EquilibriumPoint[], error: string | null }>({ points: [], error: null });

    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const handleRunSimulation = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        setSimulationResult(null);

        try {
            const paramObj = parameters.reduce((acc, p) => ({ ...acc, [p.name]: p.value }), {});

            const functionString = await generateOdeFunction(odeString, variableNames, parameters.map(p => p.name));
            
            // This is a controlled way to create a function from a string generated by a trusted source (our Gemini prompt)
            const odeFunction = new Function('t', 'y', 'params', `
                const [${variableNames.join(',')}] = y;
                const {${parameters.map(p => p.name).join(',')}} = params;
                ${functionString}
            `) as (t: number, y: number[], params: Record<string, number>) => number[];


            const result = rungeKutta4(odeFunction, simulationParams.initialConditions, simulationParams.t_start, simulationParams.t_end, simulationParams.stepSize, paramObj);
            
            // Discard transient
            const transientSteps = Math.floor(simulationParams.transient / simulationParams.stepSize);
            const finalResult: SimulationResult = {
                time: result.time.slice(transientSteps),
                series: result.series.map(s => s.slice(transientSteps)),
            };

            setSimulationResult(finalResult);
        } catch (e) {
            console.error("Simulation failed:", e);
            setError(e instanceof Error ? e.message : 'An unknown error occurred during simulation.');
        } finally {
            setIsLoading(false);
        }
    }, [odeString, variableNames, parameters, simulationParams]);

    const handleFindEquilibrium = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        setEquilibriumData({ points: [], error: null });
        try {
            const paramObj = parameters.reduce((acc, p) => ({ ...acc, [p.name]: p.value }), {});
            const points = await analyzeEquilibriumPoints(odeString, paramObj);
            setEquilibriumData({ points, error: null });
        } catch (e) {
            console.error("Equilibrium analysis failed:", e);
            const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during analysis.';
            setError(errorMessage);
            setEquilibriumData({ points: [], error: errorMessage });
        } finally {
            setIsLoading(false);
        }
    }, [odeString, parameters]);

    return (
        <div className="min-h-screen bg-gray-900 text-gray-200">
            <main className="container mx-auto px-4 py-8">
                <Hero />
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
                    <div className="lg:col-span-1 space-y-8">
                        <OdeModelInput
                            odeString={odeString}
                            setOdeString={setOdeString}
                            variableNames={variableNames}
                            setVariableNames={setVariableNames}
                            parameters={parameters}
                            setParameters={setParameters}
                        />
                        <SimulationControl
                            simulationParams={simulationParams}
                            setSimulationParams={setSimulationParams}
                            variableNames={variableNames}
                            onRun={handleRunSimulation}
                            onAnalyzeEquilibrium={handleFindEquilibrium}
                            isLoading={isLoading}
                        />
                    </div>
                    <div className="lg:col-span-2">
                        {error && <div className="bg-red-900 border border-red-700 text-red-200 px-4 py-3 rounded-lg mb-4 font-mono text-sm">{error}</div>}
                        <AnalysisDashboard 
                            result={simulationResult} 
                            variableNames={variableNames} 
                            equilibriumData={equilibriumData}
                            isLoading={isLoading}
                            odeString={odeString}
                            parameters={parameters}
                            simulationParams={simulationParams}
                        />
                    </div>
                </div>
            </main>
        </div>
    );
};

export default App;
